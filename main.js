/*
 * Shiny Hunting Game – main logic
 *
 * This JavaScript file implements the core gameplay loop for the shiny
 * hunting game described in the specification. The game consists of five
 * biomes, day and night cycles, random encounters with creatures, and a
 * codex tracking the player's collections. All persistent data is stored in
 * localStorage so progress is preserved between sessions.
 */

(() => {
  // Data definitions
  // Catch rate distribution – applied to 10 creatures in each biome in order
  const CATCH_RATES = [95, 90, 80, 75, 70, 50, 45, 40, 35, 25];

  // Define creatures and assign catch rates by biome/time order
  // This list corresponds to the images generated by generate_creatures.py.
  const creatureList = [
    'verdant_leaflon', 'verdant_barkhorn', 'verdant_dewhopper', 'verdant_suncollar', 'verdant_sproutling',
    'verdant_gloomdrake', 'verdant_shadowpouncer', 'verdant_moonfen', 'verdant_shadehopper', 'verdant_starbit',
    'desert_sunscale', 'desert_sandrunner', 'desert_cactusaur', 'desert_mirageback', 'desert_dustwing',
    'desert_dunehowl', 'desert_nightcrawler', 'desert_mirageglider', 'desert_sandshiver', 'desert_aridclaw',
    'ocean_seapup', 'ocean_coralhorn', 'ocean_tideback', 'ocean_splashfin', 'ocean_wavefoot',
    'ocean_deepglow', 'ocean_moonray', 'ocean_abyssclaw', 'ocean_mistwing', 'ocean_whirlpooler',
    'mountain_iceback', 'mountain_snowtail', 'mountain_frosthorn', 'mountain_glacierpaw', 'mountain_chilldrake',
    'mountain_iciclex', 'mountain_nightfrost', 'mountain_winterstalk', 'mountain_snowmantle', 'mountain_iceblink',
    'swamp_mudfin', 'swamp_bogmaw', 'swamp_marshclaw', 'swamp_fenrunner', 'swamp_vinecrest',
    'swamp_mireglow', 'swamp_sludgeback', 'swamp_fogwhisp', 'swamp_croakshade', 'swamp_nightvine'
  ];

  // Build creature info mapping
  const CREATURES = {};
  for (let i = 0; i < creatureList.length; i++) {
    const id = creatureList[i];
    const catchRate = CATCH_RATES[i % CATCH_RATES.length];
    const displayName = id.split('_').slice(1).join(' ');
    CREATURES[id] = {
      id,
      name: displayName.charAt(0).toUpperCase() + displayName.slice(1),
      catchRate,
      baseImg: `assets/creatures/base/${id}_base.png`,
      uniqueImg: `assets/creatures/unique/${id}_unique.png`
    };
  }

  // Biome definitions. Each biome lists the creatures that can be encountered during
  // the day and night cycles. The names correspond to the keys in CREATURES.
  const BIOMES = {
    verdant: {
      displayName: 'Verdant Glade',
      day: creatureList.slice(0, 5),
      night: creatureList.slice(5, 10),
      background: 'forest_day.png'
    },
    desert: {
      displayName: 'Scorching Dunes',
      day: creatureList.slice(10, 15),
      night: creatureList.slice(15, 20),
      background: 'desert_day.png'
    },
    ocean: {
      displayName: 'Tidal Reef',
      day: creatureList.slice(20, 25),
      night: creatureList.slice(25, 30),
      background: 'ocean_day.png'
    },
    mountain: {
      displayName: 'Frost Peaks',
      day: creatureList.slice(30, 35),
      night: creatureList.slice(35, 40),
      background: 'mountain_day.png'
    },
    swamp: {
      displayName: 'Murk Swamp',
      day: creatureList.slice(40, 45),
      night: creatureList.slice(45, 50),
      background: 'swamp_day.png'
    }
  };

  // State variables
  let codex = {};
  let gold = 0;
  let currentBiome = null;
  let currentArea = 'ranch';
  let rapidRemaining = 0;
  let pendingEncounterQueue = [];
  let lastUpdate = Date.now();

  // DOM elements
  const ranchScreen = document.getElementById('ranch-screen');
  const overworldScreen = document.getElementById('overworld-screen');
  const biomeScreen = document.getElementById('biome-screen');
  const encounterScreen = document.getElementById('encounter-screen');
  const codexScreen = document.getElementById('codex-screen');
  const ranchSummary = document.getElementById('ranch-summary');
  const worldMap = document.getElementById('world-map');
  const mapContainer = document.getElementById('map-container');
  const codexList = document.getElementById('codex-list');
  const encounterImage = document.getElementById('encounter-image');
  const encounterName = document.getElementById('encounter-name');
  const catchRateEl = document.getElementById('catch-rate');
  const encounterMessage = document.getElementById('encounter-message');
  const biomeTitle = document.getElementById('biome-title');
  const biomeBg = document.getElementById('biome-background');
  const encounterBg = document.getElementById('encounter-bg');
  const dayNightIndicator = document.getElementById('day-night-indicator');
  const biomeLog = document.getElementById('biome-log');
  const encounterCountSpan = document.getElementById('encounter-count');

  // Load saved data from localStorage
  function loadData() {
    try {
      const data = JSON.parse(localStorage.getItem('shinyData') || '{}');
      codex = data.codex || {};
      gold = data.gold || 0;
      currentBiome = data.currentBiome || null;
      lastUpdate = data.lastUpdate || Date.now();
      rapidRemaining = data.rapidRemaining || 0;
    } catch (e) {
      codex = {};
    }
    // Initialise codex entries for each creature
    for (const cid of creatureList) {
      if (!codex[cid]) {
        codex[cid] = { standard: false, radiant: false, unique: false, sighted: 0 };
      }
    }
  }

  // Save data to localStorage
  function saveData() {
    localStorage.setItem('shinyData', JSON.stringify({
      codex,
      gold,
      currentBiome,
      lastUpdate: Date.now(),
      rapidRemaining
    }));
  }

  // Determine day or night based on local time (6am–6pm is day)
  function getDayPhase() {
    const now = new Date();
    const hour = now.getHours();
    return (hour >= 6 && hour < 18) ? 'day' : 'night';
  }

  // Calculate rapid encounters based on time offline
  function calculateOfflineEncounters() {
    const now = Date.now();
    if (currentBiome) {
      const diff = now - lastUpdate;
      const minutes = Math.floor(diff / (1000 * 60));
      const count = Math.min(60, Math.floor(minutes / 10));
      rapidRemaining += count;
    }
    lastUpdate = now;
  }

  // UI screen management
  function showScreen(screen) {
    for (const el of [ranchScreen, overworldScreen, biomeScreen, encounterScreen, codexScreen]) {
      el.style.display = (el === screen) ? 'block' : 'none';
    }
    currentArea = screen.id.replace('-screen', '');
    if (screen === biomeScreen) {
      updateDayNightIndicator();
    }
    saveData();
  }

  // Update the day/night indicator and apply overlay for night
  function updateDayNightIndicator() {
    const phase = getDayPhase();
    dayNightIndicator.textContent = phase.toUpperCase();
    if (phase === 'night') {
      biomeBg.style.filter = 'brightness(0.6)';
    } else {
      biomeBg.style.filter = 'brightness(1)';
    }
  }

  // Enter a biome
  function enterBiome(biomeKey) {
    currentBiome = biomeKey;
    rapidRemaining = 0; // when entering a new biome, reset rapid
    lastUpdate = Date.now();
    biomeTitle.textContent = BIOMES[biomeKey].displayName;
    biomeBg.style.backgroundImage = `url(assets/backgrounds/${BIOMES[biomeKey].background})`;
    biomeLog.innerHTML = '';
    updateEncounterCount();
    updateDayNightIndicator();
    showScreen(biomeScreen);
  }

  // Update encounter count display
  function updateEncounterCount() {
    encounterCountSpan.textContent = rapidRemaining;
  }

  // Generate a single encounter result (returns object with creatureId and variant)
  function generateEncounterResult() {
    const phase = getDayPhase();
    const biome = BIOMES[currentBiome];
    const pool = (phase === 'day') ? biome.day : biome.night;
    const creatureId = pool[Math.floor(Math.random() * pool.length)];
    // 1/5 odds for each of the 5 creatures is inherent in random array selection
    const roll = Math.floor(Math.random() * 5000) + 1;
    let variant = 'standard';
    if (roll === 5000) {
      variant = 'unique';
    } else if (roll >= 4500) {
      variant = 'radiant';
    }
    return { creatureId, variant };
  }

  // Process queued encounters. Continues until there are no remaining rapid encounters
  // or a new creature variant triggers the encounter screen.
  function processQueue() {
    while (rapidRemaining > 0) {
      const { creatureId, variant } = generateEncounterResult();
      const info = CREATURES[creatureId];
      const entry = codex[creatureId];
      // Already captured variant?
      if (entry[variant]) {
        // Duplicate encounter: increment sighted and give gold
        entry.sighted += 1;
        gold += 1;
        logBiome(`Spotted ${info.name} (${variant}) — +1 gold`);
        rapidRemaining--;
      } else {
        // New variant: consume one encounter and show encounter screen
        rapidRemaining--;
        showEncounter({ creatureId, variant });
        return;
      }
    }
    // If we exhausted rapid encounters, return to biome screen
    updateEncounterCount();
    showScreen(biomeScreen);
  }

  // Add message to biome log (keep last 5 messages)
  function logBiome(msg) {
    const entry = document.createElement('div');
    entry.textContent = msg;
    biomeLog.appendChild(entry);
    // Limit log length
    while (biomeLog.children.length > 5) {
      biomeLog.removeChild(biomeLog.firstChild);
    }
  }

  // Show an encounter screen for a new variant
  function showEncounter({ creatureId, variant }) {
    const info = CREATURES[creatureId];
    // Set background of encounter screen based on biome
    encounterBg.style.backgroundImage = biomeBg.style.backgroundImage;
    // Choose appropriate image
    let imgSrc;
    if (variant === 'unique') {
      imgSrc = info.uniqueImg;
    } else {
      imgSrc = info.baseImg;
    }
    encounterImage.src = imgSrc;
    // Apply filter for radiant variant
    if (variant === 'radiant') {
      encounterImage.style.filter = 'hue-rotate(160deg) saturate(1.5) brightness(1.2)';
    } else {
      encounterImage.style.filter = '';
    }
    encounterName.textContent = `${info.name} (${variant.toUpperCase()})`;
    catchRateEl.textContent = `Catch chance: ${info.catchRate}%`;
    encounterMessage.textContent = '';
    // Set catch button handler
    const catchBtn = document.getElementById('catch-button');
    catchBtn.onclick = () => {
      attemptCatch(creatureId, variant);
    };
    showScreen(encounterScreen);
  }

  // Attempt to catch a creature
  function attemptCatch(creatureId, variant) {
    const info = CREATURES[creatureId];
    const entry = codex[creatureId];
    const success = Math.random() * 100 < info.catchRate;
    if (success) {
      entry[variant] = true;
      entry.sighted += 1;
      gold += 2; // reward for catching
      encounterMessage.textContent = `Success! You caught ${info.name}.`;
    } else {
      entry.sighted += 1;
      encounterMessage.textContent = `${info.name} broke free!`;
    }
    // Disable catch button to avoid double clicking
    document.getElementById('catch-button').disabled = true;
    // After short delay resume hunting
    setTimeout(() => {
      document.getElementById('catch-button').disabled = false;
      resumeHunting();
    }, 1000);
  }

  function resumeHunting() {
    // After an encounter screen, hide it and resume processing queue if needed
    if (rapidRemaining > 0) {
      // Save codex and continue with rapid queue
      showScreen(biomeScreen);
      updateEncounterCount();
      processQueue();
    } else {
      // No pending rapid encounters: return to biome screen
      showScreen(biomeScreen);
      updateEncounterCount();
    }
  }

  // Build ranch summary showing counts of caught creatures
  function buildRanchSummary() {
    const counts = {};
    for (const biomeKey in BIOMES) {
      counts[biomeKey] = { standard: 0, radiant: 0, unique: 0 };
    }
    for (const cid in codex) {
      const [biomeKey] = cid.split('_');
      const entry = codex[cid];
      if (entry.standard) counts[biomeKey].standard++;
      if (entry.radiant) counts[biomeKey].radiant++;
      if (entry.unique) counts[biomeKey].unique++;
    }
    let html = `<div>Gold: ${gold}</div>`;
    for (const biomeKey in BIOMES) {
      const biome = BIOMES[biomeKey];
      const c = counts[biomeKey];
      html += `<div><strong>${biome.displayName}:</strong> Caught ${c.standard}/10 (Std), ${c.radiant} (Rad), ${c.unique} (Uni)</div>`;
    }
    ranchSummary.innerHTML = html;
  }

  // Build codex list
  function buildCodex() {
    codexList.innerHTML = '';
    for (const cid of creatureList) {
      const info = CREATURES[cid];
      const entry = codex[cid];
      const container = document.createElement('div');
      container.classList.add('codex-entry');
      const imgEl = document.createElement('img');
      if (entry.standard || entry.radiant || entry.unique) {
        imgEl.src = info.baseImg;
        if (entry.unique) {
          imgEl.src = info.uniqueImg;
        } else if (entry.radiant) {
          imgEl.style.filter = 'hue-rotate(160deg) saturate(1.5) brightness(1.2)';
        }
      } else {
        imgEl.src = info.baseImg;
        imgEl.style.filter = 'grayscale(100%) brightness(0.3)';
      }
      const nameEl = document.createElement('div');
      nameEl.classList.add('name');
      nameEl.textContent = info.name;
      container.appendChild(imgEl);
      container.appendChild(nameEl);
      codexList.appendChild(container);
    }
  }

  // Create clickable biome regions on the map
  function setupMapRegions() {
    // Coordinates are relative percentages (left, top, width, height)
    const regions = {
      verdant: { left: 6, top: 10, width: 25, height: 30 },
      desert: { left: 38, top: 12, width: 25, height: 30 },
      mountain: { left: 70, top: 12, width: 25, height: 30 },
      swamp: { left: 10, top: 55, width: 25, height: 30 },
      ocean: { left: 58, top: 55, width: 30, height: 30 }
    };
    for (const biomeKey in regions) {
      const r = regions[biomeKey];
      const div = document.createElement('div');
      div.classList.add('map-region');
      div.style.position = 'absolute';
      div.style.left = r.left + '%';
      div.style.top = r.top + '%';
      div.style.width = r.width + '%';
      div.style.height = r.height + '%';
      div.style.cursor = 'pointer';
      div.style.background = 'rgba(0,0,0,0)';
      div.addEventListener('click', () => enterBiome(biomeKey));
      mapContainer.appendChild(div);
    }
  }

  // Attach event handlers
  function setupEventHandlers() {
    document.getElementById('go-to-overworld').onclick = () => {
      buildRanchSummary();
      showScreen(overworldScreen);
    };
    document.getElementById('return-to-ranch').onclick = () => {
      showScreen(ranchScreen);
    };
    document.getElementById('biome-to-overworld').onclick = () => {
      showScreen(overworldScreen);
    };
    document.getElementById('open-codex').onclick = () => {
      buildCodex();
      showScreen(codexScreen);
    };
    document.getElementById('close-codex').onclick = () => {
      showScreen(overworldScreen);
    };
    document.getElementById('encounter-button').onclick = () => {
      // Determine number of encounters: rapidRemaining if >0 else 1
      if (rapidRemaining > 0) {
        processQueue();
      } else {
        rapidRemaining = 1;
        processQueue();
      }
      updateEncounterCount();
    };
    // Save last update on unload
    window.addEventListener('beforeunload', () => {
      saveData();
    });
  }

  // Initialise game on load
  function init() {
    loadData();
    calculateOfflineEncounters();
    buildRanchSummary();
    setupMapRegions();
    setupEventHandlers();
    showScreen(ranchScreen);
  }

  init();
})();